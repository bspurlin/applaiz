#!/usr/bin/node

const { readdir, readdirSync } = require('fs');
const NodeID3 = require('node-id3');
const re = /(mp3|m4a|flac|wav$)/i;

// option "-s" to follow symbolic links
opt = require('node-getopt').create([['s' , '', 'short option.']]).parseSystem();

let dirobj = {};
let space = "\t";

function fst (dirname,space) {
    let fsr = {};
    fsr.directories = [];
    fsr.files = [];
    fsr.dirname = dirname;
    try {
	let files = readdirSync(dirname,{withFileTypes:"true"});
	
	for (let i =0; i < files.length; i++ ) {
	    let entry = files[i];
	    if(entry.isDirectory()) {
		fsr.directories.push(fst(dirname + "/" + entry.name));
		console.error(dirname + "/" + entry.name);
	    } else if (re.test(entry.name)) {
		    try {
			let tags = NodeID3.read(dirname + "/" + entry.name);
			const filename = entry.name;
			
			// The point of the following 4 code snippets is to explore different ways
			// of constructing a subset of an object, in this case,
			// an object consisting only of the title,artist,albums
			// fields of the multi-field object generated by NodeID3. Ideally
			// the strings  'title','artist','albums' should have to be entered
			// only once, as in snippets 1 and 4, below.  This exercise
			// is related to the general problem of creating a string from the
			// name of a variable, a very handy capability, but a kludge in
			// all programming languages I have studied.

			// 1 Using a setter with a regexp to match the desired fields
			/*
			const tobj= {
			    set: function(a) {
				for(x of Object.keys(a)){
				    if(x.match(/^(title|artist|album)$/))
					this[x]=a[x]				    
				}
			    }
			}
			tobj.set(tags);
			*/
			/*
time ./fsObj.js -s "../Music/NAXOS-25" > fsobj.NAXOS-25.3

real    1m7.260s
user    0m1.975s
sys     0m9.045s
			*/
			
			//2 Object destructuring
			//const  {artist,title,album} = tags;
			//fsr.files.push({filename,title,artist,album});
			// 3
			//fsr.files.push({filename, ...(({title,artist,album}) => ({title,artist,album}))(tags)});
			//4 The simplest
			//let tobj = {};
			//for (x of ["title","artist","album"]) tobj[x] = tags[x];
/*
real    1m6.982s
user    0m1.713s
sys     0m9.280s
*/			
			//fsr.files.push({filename, ...tobj}); // Spread syntax to add the fields of tobj
			                                     // rather than tobj itself, to the passed
			                                     // anonymous object
			fsr.files.push({filename, ...((a) => {let obj = {}; for(x of ["title","artist","album"]){obj[x]=a[x]};return obj})(tags)});
		    } catch (error) {
			console.error(entry.name + " " + error)
		    }
		
	    } else if (entry.isSymbolicLink() && opt.options.s) {
		    fsr.directories.push(fst(dirname + "/" + entry.name));
		    console.error(dirname + "/" + entry.name);
		
	    }
	}
	
    } catch (error) {console.error(dirname + " " + error)}
    return fsr
} 

out = fst(opt.argv[0]);

console.log(JSON.stringify(out,null,2));
